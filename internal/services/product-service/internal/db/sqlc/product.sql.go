// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: product.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countProductsByShop = `-- name: CountProductsByShop :one
SELECT count(*) FROM products
WHERE shop_id = $1 AND deleted_at IS NULL
`

func (q *Queries) CountProductsByShop(ctx context.Context, shopID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countProductsByShop, shopID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createProduct = `-- name: CreateProduct :one
INSERT INTO products (
    shop_id,
    product_name,
    thumbnail_url,
    product_description,
    category_id,
    price,
    currency,
    quantity,
    reserve_quantity,
    product_status
)
VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
)
RETURNING id, shop_id, product_name, thumbnail_url, product_description, category_id, price, currency, quantity, reserve_quantity, product_status, sold_count, rating_avg, total_reviews, created_at, delete_at, updated_at
`

type CreateProductParams struct {
	ShopID             pgtype.UUID    `json:"shop_id"`
	ProductName        string         `json:"product_name"`
	ThumbnailUrl       pgtype.Text    `json:"thumbnail_url"`
	ProductDescription pgtype.Text    `json:"product_description"`
	CategoryID         pgtype.UUID    `json:"category_id"`
	Price              pgtype.Numeric `json:"price"`
	Currency           string         `json:"currency"`
	Quantity           int32          `json:"quantity"`
	ReserveQuantity    int32          `json:"reserve_quantity"`
	ProductStatus      ProductStatus  `json:"product_status"`
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (Product, error) {
	row := q.db.QueryRow(ctx, createProduct,
		arg.ShopID,
		arg.ProductName,
		arg.ThumbnailUrl,
		arg.ProductDescription,
		arg.CategoryID,
		arg.Price,
		arg.Currency,
		arg.Quantity,
		arg.ReserveQuantity,
		arg.ProductStatus,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.ShopID,
		&i.ProductName,
		&i.ThumbnailUrl,
		&i.ProductDescription,
		&i.CategoryID,
		&i.Price,
		&i.Currency,
		&i.Quantity,
		&i.ReserveQuantity,
		&i.ProductStatus,
		&i.SoldCount,
		&i.RatingAvg,
		&i.TotalReviews,
		&i.CreatedAt,
		&i.DeleteAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getListProductsByShop = `-- name: GetListProductsByShop :many
SELECT id, shop_id, product_name, thumbnail_url, product_description, category_id, price, currency, quantity, reserve_quantity, product_status, sold_count, rating_avg, total_reviews, created_at, delete_at, updated_at FROM products
WHERE shop_id = $1 AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetListProductsByShopParams struct {
	ShopID pgtype.UUID `json:"shop_id"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

func (q *Queries) GetListProductsByShop(ctx context.Context, arg GetListProductsByShopParams) ([]Product, error) {
	rows, err := q.db.Query(ctx, getListProductsByShop, arg.ShopID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Product{}
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.ShopID,
			&i.ProductName,
			&i.ThumbnailUrl,
			&i.ProductDescription,
			&i.CategoryID,
			&i.Price,
			&i.Currency,
			&i.Quantity,
			&i.ReserveQuantity,
			&i.ProductStatus,
			&i.SoldCount,
			&i.RatingAvg,
			&i.TotalReviews,
			&i.CreatedAt,
			&i.DeleteAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductByID = `-- name: GetProductByID :one
SELECT id, shop_id, product_name, thumbnail_url, product_description, category_id, price, currency, quantity, reserve_quantity, product_status, sold_count, rating_avg, total_reviews, created_at, delete_at, updated_at FROM products
WHERE id = $1 AND delete_at IS NULL
`

func (q *Queries) GetProductByID(ctx context.Context, id pgtype.UUID) (Product, error) {
	row := q.db.QueryRow(ctx, getProductByID, id)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.ShopID,
		&i.ProductName,
		&i.ThumbnailUrl,
		&i.ProductDescription,
		&i.CategoryID,
		&i.Price,
		&i.Currency,
		&i.Quantity,
		&i.ReserveQuantity,
		&i.ProductStatus,
		&i.SoldCount,
		&i.RatingAvg,
		&i.TotalReviews,
		&i.CreatedAt,
		&i.DeleteAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProductsByIDs = `-- name: GetProductsByIDs :many
SELECT id, shop_id, product_name, thumbnail_url, product_description, category_id, price, currency, quantity, reserve_quantity, product_status, sold_count, rating_avg, total_reviews, created_at, delete_at, updated_at FROM products
WHERE id = ANY($1::uuid[]) AND delete_at IS NULL
`

func (q *Queries) GetProductsByIDs(ctx context.Context, productIds []pgtype.UUID) ([]Product, error) {
	rows, err := q.db.Query(ctx, getProductsByIDs, productIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Product{}
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.ShopID,
			&i.ProductName,
			&i.ThumbnailUrl,
			&i.ProductDescription,
			&i.CategoryID,
			&i.Price,
			&i.Currency,
			&i.Quantity,
			&i.ReserveQuantity,
			&i.ProductStatus,
			&i.SoldCount,
			&i.RatingAvg,
			&i.TotalReviews,
			&i.CreatedAt,
			&i.DeleteAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsByIDsForUpdate = `-- name: GetProductsByIDsForUpdate :many
SELECT id, shop_id, product_name, thumbnail_url, product_description, category_id, price, currency, quantity, reserve_quantity, product_status, sold_count, rating_avg, total_reviews, created_at, delete_at, updated_at FROM products
WHERE id = ANY($1::uuid[]) AND delete_at IS NULL
FOR UPDATE
`

func (q *Queries) GetProductsByIDsForUpdate(ctx context.Context, productIds []pgtype.UUID) ([]Product, error) {
	rows, err := q.db.Query(ctx, getProductsByIDsForUpdate, productIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Product{}
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.ShopID,
			&i.ProductName,
			&i.ThumbnailUrl,
			&i.ProductDescription,
			&i.CategoryID,
			&i.Price,
			&i.Currency,
			&i.Quantity,
			&i.ReserveQuantity,
			&i.ProductStatus,
			&i.SoldCount,
			&i.RatingAvg,
			&i.TotalReviews,
			&i.CreatedAt,
			&i.DeleteAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteProduct = `-- name: SoftDeleteProduct :exec
UPDATE products
SET
  deleted_at = NOW(),
  product_status = 'DISCONTINUED', -- Hoặc một trạng thái xóa khác
  updated_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) SoftDeleteProduct(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, softDeleteProduct, id)
	return err
}

const updateProduct = `-- name: UpdateProduct :one
UPDATE products
SET
  product_name = $2,
  product_description = $3,
  category_id = $4,
  price = $5,
  currency = $6,
  quantity = $7,
  thumbnail_url = $8,
  product_status = $9,
  updated_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, shop_id, product_name, thumbnail_url, product_description, category_id, price, currency, quantity, reserve_quantity, product_status, sold_count, rating_avg, total_reviews, created_at, delete_at, updated_at
`

type UpdateProductParams struct {
	ID                 pgtype.UUID    `json:"id"`
	ProductName        string         `json:"product_name"`
	ProductDescription pgtype.Text    `json:"product_description"`
	CategoryID         pgtype.UUID    `json:"category_id"`
	Price              pgtype.Numeric `json:"price"`
	Currency           string         `json:"currency"`
	Quantity           int32          `json:"quantity"`
	ThumbnailUrl       pgtype.Text    `json:"thumbnail_url"`
	ProductStatus      ProductStatus  `json:"product_status"`
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) (Product, error) {
	row := q.db.QueryRow(ctx, updateProduct,
		arg.ID,
		arg.ProductName,
		arg.ProductDescription,
		arg.CategoryID,
		arg.Price,
		arg.Currency,
		arg.Quantity,
		arg.ThumbnailUrl,
		arg.ProductStatus,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.ShopID,
		&i.ProductName,
		&i.ThumbnailUrl,
		&i.ProductDescription,
		&i.CategoryID,
		&i.Price,
		&i.Currency,
		&i.Quantity,
		&i.ReserveQuantity,
		&i.ProductStatus,
		&i.SoldCount,
		&i.RatingAvg,
		&i.TotalReviews,
		&i.CreatedAt,
		&i.DeleteAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateProductStock = `-- name: UpdateProductStock :one
UPDATE products
SET
    quantity = $2,
    reserve_quantity = $3,
    updated_at = NOW()
WHERE id = $1 AND delete_at IS NULL
RETURNING id, shop_id, product_name, thumbnail_url, product_description, category_id, price, currency, quantity, reserve_quantity, product_status, sold_count, rating_avg, total_reviews, created_at, delete_at, updated_at
`

type UpdateProductStockParams struct {
	ID              pgtype.UUID `json:"id"`
	Quantity        int32       `json:"quantity"`
	ReserveQuantity int32       `json:"reserve_quantity"`
}

func (q *Queries) UpdateProductStock(ctx context.Context, arg UpdateProductStockParams) (Product, error) {
	row := q.db.QueryRow(ctx, updateProductStock, arg.ID, arg.Quantity, arg.ReserveQuantity)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.ShopID,
		&i.ProductName,
		&i.ThumbnailUrl,
		&i.ProductDescription,
		&i.CategoryID,
		&i.Price,
		&i.Currency,
		&i.Quantity,
		&i.ReserveQuantity,
		&i.ProductStatus,
		&i.SoldCount,
		&i.RatingAvg,
		&i.TotalReviews,
		&i.CreatedAt,
		&i.DeleteAt,
		&i.UpdatedAt,
	)
	return i, err
}
