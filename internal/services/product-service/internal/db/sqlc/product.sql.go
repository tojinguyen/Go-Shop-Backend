// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: product.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createProduct = `-- name: CreateProduct :one
INSERT INTO products (
    shop_id,
    product_name,
    thumbnail_url,
    product_description,
    category_id,
    price,
    currency,
    quantity,
    reserve_quantity,
    product_status
)
VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
)
RETURNING id, shop_id, product_name, thumbnail_url, product_description, category_id, price, currency, quantity, reserve_quantity, product_status, sold_count, rating_avg, total_reviews, created_at, delete_at, updated_at
`

type CreateProductParams struct {
	ShopID             pgtype.UUID    `json:"shop_id"`
	ProductName        string         `json:"product_name"`
	ThumbnailUrl       pgtype.Text    `json:"thumbnail_url"`
	ProductDescription pgtype.Text    `json:"product_description"`
	CategoryID         pgtype.UUID    `json:"category_id"`
	Price              pgtype.Numeric `json:"price"`
	Currency           string         `json:"currency"`
	Quantity           int32          `json:"quantity"`
	ReserveQuantity    int32          `json:"reserve_quantity"`
	ProductStatus      ProductStatus  `json:"product_status"`
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (Product, error) {
	row := q.db.QueryRow(ctx, createProduct,
		arg.ShopID,
		arg.ProductName,
		arg.ThumbnailUrl,
		arg.ProductDescription,
		arg.CategoryID,
		arg.Price,
		arg.Currency,
		arg.Quantity,
		arg.ReserveQuantity,
		arg.ProductStatus,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.ShopID,
		&i.ProductName,
		&i.ThumbnailUrl,
		&i.ProductDescription,
		&i.CategoryID,
		&i.Price,
		&i.Currency,
		&i.Quantity,
		&i.ReserveQuantity,
		&i.ProductStatus,
		&i.SoldCount,
		&i.RatingAvg,
		&i.TotalReviews,
		&i.CreatedAt,
		&i.DeleteAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getListProductsByShop = `-- name: GetListProductsByShop :many
SELECT id, shop_id, product_name, thumbnail_url, product_description, category_id, price, currency, quantity, reserve_quantity, product_status, sold_count, rating_avg, total_reviews, created_at, delete_at, updated_at FROM products
WHERE shop_id = $1 AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetListProductsByShopParams struct {
	ShopID pgtype.UUID `json:"shop_id"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

func (q *Queries) GetListProductsByShop(ctx context.Context, arg GetListProductsByShopParams) ([]Product, error) {
	rows, err := q.db.Query(ctx, getListProductsByShop, arg.ShopID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Product{}
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.ShopID,
			&i.ProductName,
			&i.ThumbnailUrl,
			&i.ProductDescription,
			&i.CategoryID,
			&i.Price,
			&i.Currency,
			&i.Quantity,
			&i.ReserveQuantity,
			&i.ProductStatus,
			&i.SoldCount,
			&i.RatingAvg,
			&i.TotalReviews,
			&i.CreatedAt,
			&i.DeleteAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductByID = `-- name: GetProductByID :one
SELECT id, shop_id, product_name, thumbnail_url, product_description, category_id, price, currency, quantity, reserve_quantity, product_status, sold_count, rating_avg, total_reviews, created_at, delete_at, updated_at FROM products
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetProductByID(ctx context.Context, id pgtype.UUID) (Product, error) {
	row := q.db.QueryRow(ctx, getProductByID, id)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.ShopID,
		&i.ProductName,
		&i.ThumbnailUrl,
		&i.ProductDescription,
		&i.CategoryID,
		&i.Price,
		&i.Currency,
		&i.Quantity,
		&i.ReserveQuantity,
		&i.ProductStatus,
		&i.SoldCount,
		&i.RatingAvg,
		&i.TotalReviews,
		&i.CreatedAt,
		&i.DeleteAt,
		&i.UpdatedAt,
	)
	return i, err
}
